# 斯坦福课程「CS146S现代软件开发者」W1D6：AI 编程基石——从“随性聊天”到“逻辑控制”

在 W1D5 中，我们已经尝试用 Python 脚本让 AI “开口说话”了。但如果你想让 AI 成为一个稳定、可靠且能执行复杂任务的专业助手，不能只靠在聊天框里“随性发挥”。

今天，我们将学习如何利用 **Python 的核心逻辑** 为 AI 打造一套“规矩”。掌握了这节课的知识，你将完成从“AI 使用者”到“AI 开发者”的本质跨越。

> [!TIP]
> **如果你是 Python 零基础学员**
> 本课件包含必要的 Python 核心概念深度剖析。如果你希望更垂直、更系统地掌握 Python 编程，欢迎关注我们的另一个系列课程：**《Learn python with AI IDE》**。

---

### 📌 本课核心总览 (Overview)
为了把 AI 变成真正的“生产力工具”，今天我们将攻克以下四个核心关卡：
1. **数据“收纳术” (Dict & List)**：学习如何用 Python 的容器专业地存储和排序对话历史。
2. **跨越环境的“翻译官” (SDK & JSON)**：理解你的代码是如何变身为“国际通用语”并发给远端大脑的。
3. **逻辑“加工厂” (Function)**：学会将重复的 AI 调用封装成自动化的“零件”。
4. **程序的“裁判与复读机” (Bool & Loop)**：掌握如何用逻辑判断和压力测试来驯服 AI 的不确定性。

---

## 1. 数据的“居住地”：字典与列表

在让 AI 说话之前，我们首先要在自己的代码里把“要说的话”组织好。Python 为此提供了两个最强大的容器：**字典**（存标签）和**列表**（存顺序）。

### 1.1 字典 (Dictionary)：精准的标签抽屉

#### L1 入门：酒店前台的房卡墙
想象酒店前台背后的那一面钥匙墙：
- **房间号 (Key, 键)**：格子外面刻着的数字（比如“808”）。
- **房卡 (Value, 值)**：格子里面放置的房卡。
**核心逻辑**：你不需要去数第几个格子，你只要大喊“808”，前台就能瞬间精准定位。

#### L2 语法：一般形式
在 Python 中，我们用 **大括号 `{ }`** 来表示这种“标签-内容”的映射。
```python
# 每个标签（Key）对应一个内容（Value）
message = {
    "role": "system", 
    "content": "你是一个精通 Python 的资深工程师"
}

# 通过标签精准拿内容
print(message["role"])    # 输出: system
```

#### L3 深度：AI 身份的“标签化”
AI 请求中的每一句对白都是一个字典。
- **`role`**：告诉 AI 这句话是谁说的（system 设定/user 提问/assistant AI回复）。
- **`content`**：存储具体的对话文字。这就是我们要传给 AI 的原材料。

#### 💡 核心心智模型
- **字典** = 一个带标签的抽屉。你不需要记它在第几层，只需要记住它的“标签名” (Key)。
- **AI 对话** = 所有的对话本质上都是由 `role`（谁说的）和 `content`（说了什么）这两个标签组成的字典。

---

### 1.2 列表 (List)：有顺序的排队

#### L1 入门：超市收银台
想象在收银台排队的一行顾客。
- **顺位 (Index)**：排在第一位的人，他的编号是 `0`（程序员数数从 0 开始）。
- **有序性**：谁在前谁在后是固定的。

#### L2 语法：一般形式
在 Python 中，我们用 **中括号 `[ ]`** 来表示列表。
```python
# 定义列表
fruits = ["苹果", "香蕉", "橘子"]

# 根据位置拿东西
first_one = fruits[0] 
```

#### L3 深度：合体实战——对话列表 (List of Dicts)
AI 为什么有上下文记忆？因为它读的是一个由**字典组成的列表**：
```python
messages = [
    {"role": "system", "content": "你是一个 Python 导师"}, # 索引 0
    {"role": "user", "content": "什么是变量？"},           # 索引 1
    {"role": "assistant", "content": "变量是内存的标签..."}  # 索引 2
]
# 这种结构让程序能像“导演”一样，精准排布每一句对白的身份和先后顺序。
```

#### 💡 核心心智模型
- **列表** = 一列整齐的集装箱。位置比标签更重要，先后顺序决定了 AI 的“逻辑记忆”。
- **合体结构** = 在 Python 里组织对话，就是在大盒子里（列表）按时间顺序塞入小抽屉（字典）。

---

## 2. 数据的“出海之旅”：SDK 与 JSON

现在，你的对话数据已经在 Python 的内存里排好队了（List of Dicts）。但问题是：**远端的模型（可能是用 C++ 或 Go 写的）怎么能读懂这些 Python 结构呢？** 接下来，数据要经历一段“跨时空旅行”。

### 2.1 环境边界：本地 (Local) vs 服务端 (Service)
- **本地环境**：你的电脑，运行着你的 Python 脚本。
- **服务端环境**：远处的“大脑”。可能是你电脑后台运行的 Ollama，也可能是大洋彼岸的服务器。

### 2.2 SDK：你的“贴身翻译秘书”
代码开头的 `from ollama import chat` 导入的就是 **SDK (软件开发工具包)**。
- 它运行在你的**本地电脑**上，像个贴身秘书。
- 你只管对它说 Python 话（字典/列表），它负责帮你处理网络底层、封装格式这类“脏活累活”。

### 2.3 JSON：程序世界的“国际通用语”
为了跨越环境，秘书（SDK）会将数据装进一个全球公认的集装箱，这就是 **JSON**。
```json
{
  "model": "ministral",
  "messages": [
    { "role": "user", "content": "Hello" }
  ]
}
```
**JSON 的铁律 (重要考点)**：属性名和字符串**必须**使用双引号 `"`。如果你在 JSON 里写单引号 `'`，程序会直接罢工。

### 2.4 序列化 (Serialization)：变身的过程
为了发快递，SDK 会执行 **序列化** 动作：把 Python 对象压平成文本。
1. **Python `True`** ➡️ 变身 **JSON `true`**。
2. **Python `None`** ➡️ 变身 **JSON `null`**。
3. **Python `'单引号'`** ➡️ 强制升级为 **JSON `"双引号"`**。

#### 💡 核心心智模型
- **本地 (Local)**：你的地盘，说 Python 话。
- **服务端 (Service)**：对方的地盘，说 JSON 话。
- **SDK**：中间人，负责翻译、打包、跑腿。

---

## 3. 函数 (Function)：你的“逻辑加工厂”

我们已经学会了如何组织数据并发送请求。但是，作为开发者，我们不能每次都手动写几百次请求。我们需要一个**生产力倍增器**。

### L1 入门：奶茶店的自动售货机
- **配方 (函数定义)**：你写下一张纸：“拿铁 = 咖啡豆 + 牛奶”。这是一次性的准备计划。
- **原材料 (参数)**：你塞进机器的具体咖啡豆。
- **出品 (返回值)**：机器加工后吐出的一杯热拿铁。
**核心心智**：定义一次配方，按无数次按钮。

### L2 语法：定义的艺术
```python
def make_latte(bean, milk):  # def 宣告定义
    cup = f"{bean}拌{milk}"   # 内部加工逻辑
    return cup               # 把成品运出工厂
```

### L3 深度：AI 自动化裁判员
在下一课的实战脚本中，我们需要一个函数来自动判断 AI 是否答对了。这就是该函数的核心逻辑：

```python
# 这就是下一课自动化脚本里的核心逻辑零件
def verify_answer(ai_output: str, expected_output: str) -> bool:
    # 1. 数据清洗：AI 经常会吐出多余的空格或换行，必须先“卸妆”
    cleaned = ai_output.strip()
    # 2. 逻辑比对：返回布尔值结果 (通过或失败)
    return cleaned == expected_output
```
**为什么 return 如此重要？**
如果 `verify_answer` 没有 `return`，工厂做好了判断却不往外送。主程序（调用者）就永远没法根据 AI 是否成功来执行下一步。

#### 💡 核心心智模型
- **工厂 (Function)**：定义一次配方，按无数次按钮。
- **成品 (Return)**：没有传送带的工厂是死工厂，必须用 return 将结果送出。

---

## 4. 逻辑阀门：布尔值与循环

### 4.1 布尔值 (Boolean)：逻辑世界的“唯一裁判”

#### L1 入门：比喻——灯亮的瞬间
在代码世界里，只有两种绝对的状态，就像家里的电灯开关：
- **`True` (真)**：灯亮了，点头，代表肯定、正确、通过。
- **`False` (假)**：灯灭了，摇头，代表否定、错误、拒绝。
这就是布尔值的作用：它是程序做决定的“地基”。

#### L2 语法：怎么质问电脑？
我们通常通过“比对”来让电脑产出布尔值。注意：Python 中表示相等要用两个等号 **`==`**（问号感），而不是一个等号（那是赋值）。
```python
# 案例 1：质问数值
print(1 + 1 == 2)       # 结果：True (因为 1+1 确实等于 2)

# 案例 2：质问文字 (字符串)
print("apple" == "Apple") # 结果：False (因为电脑极其死板，大小写不同就不行)

# 案例 3：不相等判断
print(1 + 1 != 3)       # 结果：True (没错，它俩确实不相等)
```

#### L3 深度：决定命运的“逻辑门” (`if ... else`)
我们可以利用刚才提到的 `verify_answer` 函数返回的结果，来决定程序的操作。
```python
# 假设我们调用之前的函数
is_ok = verify_answer(ai_output="SUTATSPTTH", expected_output="SUTATSPTTH")

if is_ok:
    print("恭喜，AI 任务通过！") # 只有 True 时，才会跑这行
else:
    print("很遗憾，AI 任务失败。") # 只有 False 时，才会跑这行
```

---

### 4.2 循环 (`for ... in range`)：不知疲倦的“复读机”

#### L1 入门：比喻——绕操场跑圈
体育老师说：“绕场跑 5 圈！”
- 你跑第一圈，心里想的是：`0`（记住：程序员习惯从 0 开始数）。
- 你跑完最后一圈，心里想的是：`4`。
这就是循环：让那段枯燥的代码，按你的意志重复跑很多遍。

#### L2 语法：数字的“盒子”
在 Python 中，`range(5)` 会生成一个有序的数字盒子：`[0, 1, 2, 3, 4]`。
```python
# 翻译：对于盒子里每一个数字 i，都执行一次缩进后的代码
for i in range(5):
    # i 会在每一圈依次坐上 0, 1, 2, 3, 4 的位置
    print(f"当前是第 {i + 1} 圈") 
```

#### L3 深度：由于 AI 的“脾气”，我们必须循环
为什么我们要学循环？因为 AI 是一个**概率模型**。
- 如果 AI 答对一次，那可能只是运气好（瞎猫撞到死耗子）。
- **工程思维**：一个成熟的开发者，会用循环让同一段 Prompt 跑 **5 次到 10 次**。如果 10 次里有 9 次都能通，这种 Prompt 才叫有**稳健性 (Robustness)**。循环，就是我们给 AI 做的“压力测试”。

#### 💡 核心心智模型
- **裁判员 (Bool)**：给 AI 打分的唯一刻度尺。
- **复读机 (Loop)**：不被偶然的成功蒙蔽，用重复验证 AI 的真实实力。

---

## 5. 本课总结与任务

今天我们按照一条完整的“数据生命线”完成了学习：
1. **组织 (本地)**：用字典和列表在 Python 里把话安排好。
2. **通信 (外交)**：通过 SDK 将数据序列化为 JSON 发给 AI。
3. **复用 (工厂)**：用函数封装这一系列动作。
4. **控制 (管理)**：用布尔值和循环确保 AI 的回答是稳定的、正确的。

### 课后任务：
1. 在你的代码编辑器中，定义一个存储了 3 个 AI 消息字典的**列表**。
2. 编写一个函数，接受这个列表并打印出其中第二条消息的内容。
3. 尝试编写一个循环，让你的函数连续运行 3 次。

---

## 预告：写下你的第一个测试脚本
在下一课 (W1D7) 中，我们将把今天学到的所有“地基零件”拼凑在一起，去解决一个真正的难题：**如何通过“示例 (K-shot)”教 AI 学会复杂的字符逻辑，并自动验证它的准确率。**
